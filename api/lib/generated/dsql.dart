import 'package:dsql/dsql.dart';

// **************************
// Generated by DSQL don't change by hand!
// **************************

// UserEntity

/// An entity created based on .sql file founded on migrations folder
class UserEntity {
  final String id;
  final String name;
  final String email;
  final String password;
  final String image;
  final DateTime createdAt;
  final DateTime updatedAt;

  const UserEntity({
    required this.id,
    required this.name,
    required this.email,
    required this.password,
    required this.image,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'email': email,
      'password': password,
      'image': image,
      'created_at': createdAt.millisecondsSinceEpoch,
      'updated_at': updatedAt.millisecondsSinceEpoch,
    };
  }

  factory UserEntity.fromMap(Map<String, dynamic> map) {
    return UserEntity(
      id: map['id'] as String,
      name: map['name'] as String,
      email: map['email'] as String,
      password: map['password'] as String,
      image: map['image'] as String,
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at'] as int),
      updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at'] as int),
    );
  }

  factory UserEntity.fromRow(List row) {
    final [
      String id,
      String name,
      String email,
      String password,
      String image,
      DateTime createdAt,
      DateTime updatedAt,
    ] = row;

    return UserEntity(
      id: id,
      name: name,
      email: email,
      password: password,
      image: image,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  @override
  String toString() {
    return 'UserEntity(id: $id, name: $name, email: $email, password: $password, image: $image, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(covariant UserEntity other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;

    return id == other.id && name == other.name && email == other.email && password == other.password && image == other.image && createdAt == other.createdAt && updatedAt == other.updatedAt;
  }

  @override
  int get hashCode {
    return id.hashCode ^ name.hashCode ^ email.hashCode ^ password.hashCode ^ image.hashCode ^ createdAt.hashCode ^ updatedAt.hashCode;
  }
}

// AuthEntity

/// An entity created based on .sql file founded on migrations folder
class AuthEntity {
  final String userId;
  final String accessToken;
  final String refreshToken;
  final DateTime createdAt;

  const AuthEntity({
    required this.userId,
    required this.accessToken,
    required this.refreshToken,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'user_id': userId,
      'access_token': accessToken,
      'refresh_token': refreshToken,
      'created_at': createdAt.millisecondsSinceEpoch,
    };
  }

  factory AuthEntity.fromMap(Map<String, dynamic> map) {
    return AuthEntity(
      userId: map['user_id'] as String,
      accessToken: map['access_token'] as String,
      refreshToken: map['refresh_token'] as String,
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at'] as int),
    );
  }

  factory AuthEntity.fromRow(List row) {
    final [
      String userId,
      String accessToken,
      String refreshToken,
      DateTime createdAt,
    ] = row;

    return AuthEntity(
      userId: userId,
      accessToken: accessToken,
      refreshToken: refreshToken,
      createdAt: createdAt,
    );
  }

  @override
  String toString() {
    return 'AuthEntity(userId: $userId, accessToken: $accessToken, refreshToken: $refreshToken, createdAt: $createdAt)';
  }

  @override
  bool operator ==(covariant AuthEntity other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;

    return userId == other.userId && accessToken == other.accessToken && refreshToken == other.refreshToken && createdAt == other.createdAt;
  }

  @override
  int get hashCode {
    return userId.hashCode ^ accessToken.hashCode ^ refreshToken.hashCode ^ createdAt.hashCode;
  }
}

// FriendRequestEntity

/// An entity created based on .sql file founded on migrations folder
class FriendRequestEntity {
  final String id;
  final String userId;
  final String friendId;
  final DateTime createdAt;

  const FriendRequestEntity({
    required this.id,
    required this.userId,
    required this.friendId,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'user_id': userId,
      'friend_id': friendId,
      'created_at': createdAt.millisecondsSinceEpoch,
    };
  }

  factory FriendRequestEntity.fromMap(Map<String, dynamic> map) {
    return FriendRequestEntity(
      id: map['id'] as String,
      userId: map['user_id'] as String,
      friendId: map['friend_id'] as String,
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at'] as int),
    );
  }

  factory FriendRequestEntity.fromRow(List row) {
    final [
      String id,
      String userId,
      String friendId,
      DateTime createdAt,
    ] = row;

    return FriendRequestEntity(
      id: id,
      userId: userId,
      friendId: friendId,
      createdAt: createdAt,
    );
  }

  @override
  String toString() {
    return 'FriendRequestEntity(id: $id, userId: $userId, friendId: $friendId, createdAt: $createdAt)';
  }

  @override
  bool operator ==(covariant FriendRequestEntity other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;

    return id == other.id && userId == other.userId && friendId == other.friendId && createdAt == other.createdAt;
  }

  @override
  int get hashCode {
    return id.hashCode ^ userId.hashCode ^ friendId.hashCode ^ createdAt.hashCode;
  }
}

// FriendEntity

/// An entity created based on .sql file founded on migrations folder
class FriendEntity {
  final String id;
  final String userId;
  final String friendId;
  final DateTime createdAt;

  const FriendEntity({
    required this.id,
    required this.userId,
    required this.friendId,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'user_id': userId,
      'friend_id': friendId,
      'created_at': createdAt.millisecondsSinceEpoch,
    };
  }

  factory FriendEntity.fromMap(Map<String, dynamic> map) {
    return FriendEntity(
      id: map['id'] as String,
      userId: map['user_id'] as String,
      friendId: map['friend_id'] as String,
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at'] as int),
    );
  }

  factory FriendEntity.fromRow(List row) {
    final [
      String id,
      String userId,
      String friendId,
      DateTime createdAt,
    ] = row;

    return FriendEntity(
      id: id,
      userId: userId,
      friendId: friendId,
      createdAt: createdAt,
    );
  }

  @override
  String toString() {
    return 'FriendEntity(id: $id, userId: $userId, friendId: $friendId, createdAt: $createdAt)';
  }

  @override
  bool operator ==(covariant FriendEntity other) {
    if (identical(this, other)) return true;
    if (runtimeType != other.runtimeType) return false;

    return id == other.id && userId == other.userId && friendId == other.friendId && createdAt == other.createdAt;
  }

  @override
  int get hashCode {
    return id.hashCode ^ userId.hashCode ^ friendId.hashCode ^ createdAt.hashCode;
  }
}

// UserRepository

/// Repository for UserEntity
class UserRepository {
  final PostgreSQLConnection conn;

  const UserRepository(this.conn);

  /// Creates a new [UserEntity] in database
  Future<UserEntity> create({
    required String name,
    required String email,
    required String password,
  }) async {
    try {
      final result = await conn.query(
        'INSERT INTO chat.tb_users (name, email, password) VALUES (@name, @email, @password) RETURNING *',
        substitutionValues: {
          'name': name,
          'email': email,
          'password': password,
        },
      );

      return UserEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a list of [UserEntity] from database
  Future<List<UserEntity>> findMany({
    Where? where,
    OrderBy? orderBy,
    int? limit,
    int? offset,
  }) async {
    try {
      final orderByOffsetAndLimit = '${orderBy != null ? '${orderBy.queryString} ' : ''}${offset != null ? 'OFFSET $offset ' : ''}${limit != null ? 'LIMIT $limit' : ''}';

      PostgreSQLResult result;

      if (where != null) {
        result = await conn.query(
          'SELECT * FROM chat.tb_users WHERE ${where.queryString}${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};',
          substitutionValues: where.substitutionValues,
        );
      } else {
        result = await conn.query('SELECT * FROM chat.tb_users${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};');
      }

      return result.map(UserEntity.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a single [UserEntity] from database if exists
  Future<UserEntity?> findFirst({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'SELECT * FROM chat.tb_users WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} LIMIT 1;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? UserEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Updates a [UserEntity] in database
  Future<UserEntity> update({
    String? name,
    String? email,
    String? password,
    String? image,
    DateTime? createdAt,
    DateTime? updatedAt,
    required Where where,
  }) async {
    try {
      final valuesToUpdate = <String, dynamic>{
        if (name != null) 'name': name,
        if (email != null) 'email': email,
        if (password != null) 'password': password,
        if (image != null) 'image': image,
        if (createdAt != null) 'createdAt': createdAt,
        if (updatedAt != null) 'updatedAt': updatedAt,
      };

      if (valuesToUpdate.isEmpty) {
        throw Exception('You must provide at least one value to update!');
      }

      final result = await conn.query(
        'UPDATE chat.tb_users SET ${valuesToUpdate.entries.map((e) => '${DSQLUtils.toSnakeCase(e.key)} = @${e.key}').join(', ')} WHERE ${where.queryString} RETURNING *;',
        substitutionValues: {
          ...valuesToUpdate,
          ...where.substitutionValues,
        },
      );

      if (result.isEmpty) {
        throw Exception('UserEntity not found!');
      }

      return UserEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Deletes a [UserEntity] from database
  Future<UserEntity?> delete({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'DELETE FROM chat.tb_users WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} RETURNING *;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? UserEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<int> aggregate({
    Where? where,
  }) async {
    try {
      final result = await conn.query(
        'SELECT COUNT(*) FROM chat.tb_users${where != null ? ' WHERE ${where.queryString}' : ''};',
        substitutionValues: where?.substitutionValues,
      );

      final [count] = result.first;

      return count;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
}

// AuthRepository

/// Repository for AuthEntity
class AuthRepository {
  final PostgreSQLConnection conn;

  const AuthRepository(this.conn);

  /// Creates a new [AuthEntity] in database
  Future<AuthEntity> create({
    required String userId,
    required String accessToken,
    required String refreshToken,
  }) async {
    try {
      final result = await conn.query(
        'INSERT INTO chat.tb_auth (user_id, access_token, refresh_token) VALUES (@userId, @accessToken, @refreshToken) RETURNING *',
        substitutionValues: {
          'userId': userId,
          'accessToken': accessToken,
          'refreshToken': refreshToken,
        },
      );

      return AuthEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a list of [AuthEntity] from database
  Future<List<AuthEntity>> findMany({
    Where? where,
    OrderBy? orderBy,
    int? limit,
    int? offset,
  }) async {
    try {
      final orderByOffsetAndLimit = '${orderBy != null ? '${orderBy.queryString} ' : ''}${offset != null ? 'OFFSET $offset ' : ''}${limit != null ? 'LIMIT $limit' : ''}';

      PostgreSQLResult result;

      if (where != null) {
        result = await conn.query(
          'SELECT * FROM chat.tb_auth WHERE ${where.queryString}${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};',
          substitutionValues: where.substitutionValues,
        );
      } else {
        result = await conn.query('SELECT * FROM chat.tb_auth${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};');
      }

      return result.map(AuthEntity.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a single [AuthEntity] from database if exists
  Future<AuthEntity?> findFirst({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'SELECT * FROM chat.tb_auth WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} LIMIT 1;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? AuthEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Updates a [AuthEntity] in database
  Future<AuthEntity> update({
    String? userId,
    String? accessToken,
    String? refreshToken,
    DateTime? createdAt,
    required Where where,
  }) async {
    try {
      final valuesToUpdate = <String, dynamic>{
        if (userId != null) 'userId': userId,
        if (accessToken != null) 'accessToken': accessToken,
        if (refreshToken != null) 'refreshToken': refreshToken,
        if (createdAt != null) 'createdAt': createdAt,
      };

      if (valuesToUpdate.isEmpty) {
        throw Exception('You must provide at least one value to update!');
      }

      final result = await conn.query(
        'UPDATE chat.tb_auth SET ${valuesToUpdate.entries.map((e) => '${DSQLUtils.toSnakeCase(e.key)} = @${e.key}').join(', ')} WHERE ${where.queryString} RETURNING *;',
        substitutionValues: {
          ...valuesToUpdate,
          ...where.substitutionValues,
        },
      );

      if (result.isEmpty) {
        throw Exception('AuthEntity not found!');
      }

      return AuthEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Deletes a [AuthEntity] from database
  Future<AuthEntity?> delete({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'DELETE FROM chat.tb_auth WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} RETURNING *;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? AuthEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<int> aggregate({
    Where? where,
  }) async {
    try {
      final result = await conn.query(
        'SELECT COUNT(*) FROM chat.tb_auth${where != null ? ' WHERE ${where.queryString}' : ''};',
        substitutionValues: where?.substitutionValues,
      );

      final [count] = result.first;

      return count;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
}

// FriendRequestRepository

/// Repository for FriendRequestEntity
class FriendRequestRepository {
  final PostgreSQLConnection conn;

  const FriendRequestRepository(this.conn);

  /// Creates a new [FriendRequestEntity] in database
  Future<FriendRequestEntity> create({
    required String userId,
    required String friendId,
  }) async {
    try {
      final result = await conn.query(
        'INSERT INTO chat.tb_friend_requests (user_id, friend_id) VALUES (@userId, @friendId) RETURNING *',
        substitutionValues: {
          'userId': userId,
          'friendId': friendId,
        },
      );

      return FriendRequestEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a list of [FriendRequestEntity] from database
  Future<List<FriendRequestEntity>> findMany({
    Where? where,
    OrderBy? orderBy,
    int? limit,
    int? offset,
  }) async {
    try {
      final orderByOffsetAndLimit = '${orderBy != null ? '${orderBy.queryString} ' : ''}${offset != null ? 'OFFSET $offset ' : ''}${limit != null ? 'LIMIT $limit' : ''}';

      PostgreSQLResult result;

      if (where != null) {
        result = await conn.query(
          'SELECT * FROM chat.tb_friend_requests WHERE ${where.queryString}${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};',
          substitutionValues: where.substitutionValues,
        );
      } else {
        result = await conn.query('SELECT * FROM chat.tb_friend_requests${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};');
      }

      return result.map(FriendRequestEntity.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a single [FriendRequestEntity] from database if exists
  Future<FriendRequestEntity?> findFirst({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'SELECT * FROM chat.tb_friend_requests WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} LIMIT 1;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? FriendRequestEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Updates a [FriendRequestEntity] in database
  Future<FriendRequestEntity> update({
    String? userId,
    String? friendId,
    DateTime? createdAt,
    required Where where,
  }) async {
    try {
      final valuesToUpdate = <String, dynamic>{
        if (userId != null) 'userId': userId,
        if (friendId != null) 'friendId': friendId,
        if (createdAt != null) 'createdAt': createdAt,
      };

      if (valuesToUpdate.isEmpty) {
        throw Exception('You must provide at least one value to update!');
      }

      final result = await conn.query(
        'UPDATE chat.tb_friend_requests SET ${valuesToUpdate.entries.map((e) => '${DSQLUtils.toSnakeCase(e.key)} = @${e.key}').join(', ')} WHERE ${where.queryString} RETURNING *;',
        substitutionValues: {
          ...valuesToUpdate,
          ...where.substitutionValues,
        },
      );

      if (result.isEmpty) {
        throw Exception('FriendRequestEntity not found!');
      }

      return FriendRequestEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Deletes a [FriendRequestEntity] from database
  Future<FriendRequestEntity?> delete({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'DELETE FROM chat.tb_friend_requests WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} RETURNING *;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? FriendRequestEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<int> aggregate({
    Where? where,
  }) async {
    try {
      final result = await conn.query(
        'SELECT COUNT(*) FROM chat.tb_friend_requests${where != null ? ' WHERE ${where.queryString}' : ''};',
        substitutionValues: where?.substitutionValues,
      );

      final [count] = result.first;

      return count;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
}

// FriendRepository

/// Repository for FriendEntity
class FriendRepository {
  final PostgreSQLConnection conn;

  const FriendRepository(this.conn);

  /// Creates a new [FriendEntity] in database
  Future<FriendEntity> create({
    required String userId,
    required String friendId,
  }) async {
    try {
      final result = await conn.query(
        'INSERT INTO chat.tb_friends (user_id, friend_id) VALUES (@userId, @friendId) RETURNING *',
        substitutionValues: {
          'userId': userId,
          'friendId': friendId,
        },
      );

      return FriendEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a list of [FriendEntity] from database
  Future<List<FriendEntity>> findMany({
    Where? where,
    OrderBy? orderBy,
    int? limit,
    int? offset,
  }) async {
    try {
      final orderByOffsetAndLimit = '${orderBy != null ? '${orderBy.queryString} ' : ''}${offset != null ? 'OFFSET $offset ' : ''}${limit != null ? 'LIMIT $limit' : ''}';

      PostgreSQLResult result;

      if (where != null) {
        result = await conn.query(
          'SELECT * FROM chat.tb_friends WHERE ${where.queryString}${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};',
          substitutionValues: where.substitutionValues,
        );
      } else {
        result = await conn.query('SELECT * FROM chat.tb_friends${orderByOffsetAndLimit.isNotEmpty ? ' $orderByOffsetAndLimit' : ''};');
      }

      return result.map(FriendEntity.fromRow).toList();
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Returns a single [FriendEntity] from database if exists
  Future<FriendEntity?> findFirst({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'SELECT * FROM chat.tb_friends WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} LIMIT 1;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? FriendEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Updates a [FriendEntity] in database
  Future<FriendEntity> update({
    String? userId,
    String? friendId,
    DateTime? createdAt,
    required Where where,
  }) async {
    try {
      final valuesToUpdate = <String, dynamic>{
        if (userId != null) 'userId': userId,
        if (friendId != null) 'friendId': friendId,
        if (createdAt != null) 'createdAt': createdAt,
      };

      if (valuesToUpdate.isEmpty) {
        throw Exception('You must provide at least one value to update!');
      }

      final result = await conn.query(
        'UPDATE chat.tb_friends SET ${valuesToUpdate.entries.map((e) => '${DSQLUtils.toSnakeCase(e.key)} = @${e.key}').join(', ')} WHERE ${where.queryString} RETURNING *;',
        substitutionValues: {
          ...valuesToUpdate,
          ...where.substitutionValues,
        },
      );

      if (result.isEmpty) {
        throw Exception('FriendEntity not found!');
      }

      return FriendEntity.fromRow(result.first);
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  /// Deletes a [FriendEntity] from database
  Future<FriendEntity?> delete({
    required Where where,
    OrderBy? orderBy,
  }) async {
    try {
      final result = await conn.query(
        'DELETE FROM chat.tb_friends WHERE ${where.queryString}${orderBy != null ? ' ${orderBy.queryString}' : ''} RETURNING *;',
        substitutionValues: where.substitutionValues,
      );

      return result.isNotEmpty ? FriendEntity.fromRow(result.first) : null;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }

  Future<int> aggregate({
    Where? where,
  }) async {
    try {
      final result = await conn.query(
        'SELECT COUNT(*) FROM chat.tb_friends${where != null ? ' WHERE ${where.queryString}' : ''};',
        substitutionValues: where?.substitutionValues,
      );

      final [count] = result.first;

      return count;
    } on PostgreSQLException catch (e) {
      throw Exception(e.message);
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
}

class DSQL {
  final Uri databaseURL = Uri.parse('postgres://postgres:postgres@localhost:5432/postgres?schema=chat');

  late final PostgreSQLConnection _conn;

  late final UserRepository _userRepository;

  late final AuthRepository _authRepository;

  late final FriendRequestRepository _friendRequestRepository;

  late final FriendRepository _friendRepository;

  UserRepository get user => _userRepository;

  AuthRepository get auth => _authRepository;

  FriendRequestRepository get friendRequest => _friendRequestRepository;

  FriendRepository get friend => _friendRepository;

  DSQL._() {
    final userInfo = databaseURL.userInfo.split(':');

    _conn = PostgreSQLConnection(
      databaseURL.host,
      databaseURL.port,
      databaseURL.pathSegments.isNotEmpty ? databaseURL.pathSegments.first : '',
      username: userInfo.isNotEmpty ? Uri.decodeComponent(userInfo[0]) : '',
      password: userInfo.length > 1 ? Uri.decodeComponent(userInfo[1]) : '',
      useSSL: databaseURL.queryParameters['sslmode'] == 'require',
    );

    _userRepository = UserRepository(_conn);

    _authRepository = AuthRepository(_conn);

    _friendRequestRepository = FriendRequestRepository(_conn);

    _friendRepository = FriendRepository(_conn);
  }

  static Future<DSQL> init() async {
    final dsql = DSQL._();
    await dsql._conn.open();
    await dsql._conn.execute('SET search_path = ${dsql.databaseURL.queryParameters['schema'] ?? 'public'};');
    print('DSQL initialized!');
    return dsql;
  }
}
